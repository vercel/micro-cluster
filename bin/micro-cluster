#!/usr/bin/env node

import {parse as parseUrl} from 'url'
import {dirname, resolve} from 'path'
import {METHODS} from 'http'
import program from 'commander'
import {spawn} from 'mz/child_process'
import micro from 'micro'
import {createProxyServer} from 'http-proxy'
import getPort from 'get-port'
import babelRegister from 'babel-register'
import presetES2015 from 'babel-preset-es2015'
import transformAsyncToGenerator from 'babel-plugin-transform-async-to-generator'
// eslint-disable-next-line import/no-unresolved
import {version} from '../../package'

const isHttpMethod = method => METHODS.includes(method)
const isString = value => (typeof value === 'string')

babelRegister({
  presets: [presetES2015],
  plugins: [transformAsyncToGenerator]
})

program
.version(version)
.option('-p, --port <port>', 'Port to listen on (3000)', parseInt)
.parse(process.argv)

const programPort = program.port || 3000
const file = resolve(process.cwd(), program.args[0] || 'app.js')

main()
.catch(err => {
  process.nextTick(() => {
    throw err
  })
})

async function main() {
  // eslint-disable-next-line import/no-dynamic-require
  const config = require(file).default
  const services = new Map()

  for (const id of Object.keys(config.services)) {
    let service = config.services[id]
    if (isString(service)) {
      service = {path: service}
    }

    const path = resolve(dirname(file), service.path)
    const env = service.env ? Object.assign({}, process.env, service.env) : process.env
    const port = service.port || await getPort()

    const opts = {env, stdio: 'inherit', customFds: [0, 1, 2]}
    await spawn(resolve(__dirname, 'micro'), ['--port', port, path], opts)
    services.set(id, port)
  }

  // wait for starting servers
  await sleep(1000)

  const proxyServer = createProxyServer()
  const locations = Object.keys(config.locations)
  .map(l => {
    let location = config.locations[l]
    if (isString(location)) {
      location = {proxy: location}
    }

    const rewrite = location.rewrite ?
      [new RegExp(location.rewrite[0].replace(/\//, '\\/')), ...location.rewrite.slice(1)] :
      null

    const match = new RegExp(l.replace(/\//g, '\\/'))

    let method = []
    if (location.method) {
      if (isString(location.method) && isHttpMethod(location.method)) {
        method.push(location.method)
      } else if (Array.isArray(location.method)) {
        method = location.method.filter(httpMethod => isHttpMethod(httpMethod))
      }
    }

    return Object.assign({}, location, {rewrite, match, method})
  })

  proxyServer.on('proxyReq', (proxyReq, req) => {
    if (req.proxySetHeaders) {
      Object.keys(req.proxySetHeaders).forEach(key => {
        proxyReq.setHeader(key, req.proxySetHeaders[key])
      })
    }
  })

  micro(async (req, res) => {
    const {pathname, search} = parseUrl(req.url)
    const requestMethod = req.method

    for (const {match, rewrite, proxy, proxySetHeaders, method} of locations) {
      if (!match.test(pathname)) {
        continue
      }

      if (method.length > 0 && !method.includes(requestMethod)) {
        continue
      }

      const newPathname = rewrite ?
        pathname.replace.apply(pathname, rewrite) :
        pathname
      const port = services.get(proxy)

      if (proxySetHeaders) {
        req.proxySetHeaders = proxySetHeaders
      }

      const target = `http://localhost:${port}${newPathname}${search || ''}`
      proxyServer.web(req, res, {target, ignorePath: true})
      return
    }

    res.writeHead(404)
    res.end('Not found')
  }).listen(programPort, err => {
    if (err) {
      console.error(err.stack)
      process.exit(1)
    }

    console.log(`> \u001b[96mReady!\u001b[39m Listening on ${programPort}.`)
  })
}

async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}
